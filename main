import tkinter
from tkinter import *
from tkinter import scrolledtext, messagebox
from tkinter import ttk
variable = 0

# Opening the list of books
books = open("books.txt", "r+").read()
book_list = books.split("\n")

# Opening the list of authors
authors = open("authors.txt", "r+").read()
author_list = authors.split("\n")

# Opening the list of types
types = open("types.txt", "r+").read()
type_list = types.split("\n")

# Opening the list of ISBNs
ISBNs = open("ISBNs.txt", "r+").read()
ISBN_list = ISBNs.split("\n")


def read_library_data():
    try:
        with open("books.txt", "r", encoding="utf-8") as f1, open("authors.txt", "r", encoding="utf-8") as f2, open(
                  "types.txt", "r", encoding="utf-8") as f3, open("ISBNs.txt", "r", encoding="utf-8") as f4:

            read_titles = [line.strip() for line in f1.readlines()]
            read_authors = [line.strip() for line in f2.readlines()]
            read_types = [line.strip() for line in f3.readlines()]
            read_isbns = [line.strip() for line in f4.readlines()]

            # Ensure all lists are of equal length
            min_length = min(len(read_titles), len(read_authors), len(read_types))
            return list(zip(read_titles[:min_length], read_authors[:min_length], read_types[:min_length], read_isbns[:min_length]))

    except FileNotFoundError as e:
        print(f"Error: {e}")
        return []


def display_books():
    # Clear existing rows
    for row in tree.get_children():
        tree.delete(row)

    # Insert new rows
    for idx, (title, author, book_type, isbn) in enumerate(read_library_data(), start=1):
        tree.insert("", "end", values=(idx-1, title, author, book_type, isbn))


def print_stuff():
    global books
    global book_list
    global authors
    global author_list
    global types
    global type_list
    global ISBNs
    global ISBN_list
    books = open("books.txt", "r+").read()
    book_list = books.split("\n")
    authors = open("authors.txt", "r+").read()
    author_list = authors.split("\n")
    types = open("types.txt", "r+").read()
    type_list = types.split("\n")
    ISBNs = open("ISBNs.txt", "r+").read()
    ISBN_list = ISBNs.split("\n")
    list_window = Toplevel()
    list_window.title("Entries:")
    list_area = scrolledtext.ScrolledText(list_window, wrap=tkinter.WORD, width=60, height=20)
    for i in range(len(book_list)):
        if type_list[i] == "Book":
            list_area.insert(END, str(i) + ". " + book_list[i])
            list_area.insert(END, "\n      By " + author_list[i] + " (" + type_list[i] + ")" + "(ISBN: " + ISBN_list[i] + ")")
        elif type_list[i] == "Movie":
            list_area.insert(END, str(i) + ". " + book_list[i])
            list_area.insert(END, "\n      Directed by " + author_list[i] + " (" + type_list[i] + ")")
        else:
            list_area.insert(END, str(i) + ". " + book_list[i])
            list_area.insert(END, "\n      By " + author_list[i] + " (" + type_list[i] + ")")
        list_area.insert(END, "\n")
    list_area.pack(fill=BOTH, side=LEFT, expand=TRUE)
    open("books.txt", "r+").close()
    open("authors.txt", "r+").close()
    open("types.txt", "r+").close()
    open("ISBNs.txt", "r+").close()
    return "nothing"


def edit_book():
    try:
        num = int(bookNumberInputArea.get())
    except ValueError:
        messagebox.showerror("Error", "Entry number must be an integer")
    else:
        global books
        global book_list
        books = open("books.txt", "r").read()
        book_list = books.split("\n")
        lines = open("books.txt", "r").readlines()
        if len(bookNumberInputArea.get()) > 0 and len(bookTitleInputArea.get()) > 0:
            try:
                int(bookNumberInputArea.get())
            except():
                print("no")
            else:
                if 0 <= int(bookNumberInputArea.get()) <= len(lines):
                    if bookTitleInputArea.get() in book_list:  # If inputted value is a duplicate
                        messagebox.showerror("Error", "Duplicate book name")
                    else:
                        lines[int(bookNumberInputArea.get())] = bookTitleInputArea.get() + "\n"
        with open("books.txt", "w+") as file:
            for line in lines:
                file.write(line)
            file.close()
        return "nothing"


def edit_author():
    try:
        num = int(bookNumberAuthorInputArea.get())
    except ValueError:
        messagebox.showerror("Error", "Entry number must be an integer")
    else:
        global authors
        global author_list
        authors = open("authors.txt", "r").read()
        author_list = authors.split("\n")
        lines = open("authors.txt", "r").readlines()
        if len(bookNumberAuthorInputArea.get()) > 0 and len(bookAuthorInputArea.get()) > 0:
            if 0 <= int(bookNumberAuthorInputArea.get()) <= len(lines):
                lines[int(bookNumberAuthorInputArea.get())] = bookAuthorInputArea.get() + "\n"
            else:
                messagebox.showerror("Error", "Invalid entry number")
        else:
            messagebox.showerror("Error", "One or more fields are empty")
        with open("authors.txt", "w+") as file:
            for line in lines:
                file.write(line)
            file.close()
        return "nothing"


def edit_type():
    try:
        num = int(bookNumberTypeInputArea.get())
    except ValueError:
        messagebox.showerror("Error", "Entry number must be an integer")
    else:
        with open("types.txt", "r") as file:
            lines = file.readlines()
            file.close()
        if len(bookNumberTypeInputArea.get()) > 0 and len(bookTypeInputArea.get()) > 0:
            if 0 <= int(bookNumberTypeInputArea.get()) <= len(lines):
                lines[int(bookNumberTypeInputArea.get())] = bookTypeInputArea.get() + "\n"
            else:
                messagebox.showerror("Error", "Invalid entry number")
        else:
            messagebox.showerror("Error", "One or more fields are empty")
        with open("types.txt", "w+") as file:
            for line in lines:
                file.write(line)
            file.close()
        return "nothing"


def edit_isbn():
    try:
        num = int(bookNumberISBNInputArea.get())
    except ValueError:
        messagebox.showerror("Error", "Entry number must be an integer")
    else:
        global ISBNs
        global ISBN_list
        ISBNs = open("ISBNs.txt", "r").read()
        ISBN_list = ISBNs.split("\n")
        lines = open("ISBNs.txt", "r").readlines()
        if len(bookNumberISBNInputArea.get()) > 0:
            try:
                int(bookNumberISBNInputArea.get())
            except():
                messagebox.showerror("Error", "ISBN number must be an integer")
            else:
                if int(bookNumberISBNInputArea.get()) <= len(lines):
                    # ISBN-13 checker
                    if int(bookISBNInputArea.get()[0]) == 9 and int(bookISBNInputArea.get()[1]) == 7 and (int(bookISBNInputArea.get()[2]) == 8 or int(bookISBNInputArea.get()[2]) == 9) and (int(bookISBNInputArea.get()[0]) + int(bookISBNInputArea.get()[1])*3 + int(bookISBNInputArea.get()[2]) + int(bookISBNInputArea.get()[3])*3 + int(bookISBNInputArea.get()[4]) + int(bookISBNInputArea.get()[5])*3 + int(bookISBNInputArea.get()[6]) + int(bookISBNInputArea.get()[7])*3 + int(bookISBNInputArea.get()[8]) + int(bookISBNInputArea.get()[9])*3 + int(bookISBNInputArea.get()[10]) + int(bookISBNInputArea.get()[11])*3 + int(bookISBNInputArea.get()[12])) % 10 == 0 and len(bookISBNInputArea.get()) == 13:
                        if bookISBNInputArea.get() in ISBN_list:  # If inputted value is a duplicate
                            messagebox.showerror("Error", "Duplicate ISBN number")
                        else:
                            lines[int(bookNumberISBNInputArea.get())] = bookISBNInputArea.get() + "\n"
                    else:
                        messagebox.showerror("Error", "Invalid ISBN number")
        with open("ISBNs.txt", "w+") as file:
            for line in lines:
                file.write(line)
            file.close()
        return "nothing"


def save_new_entry():
    with open("books.txt", "a+") as books_file:
        with open("authors.txt", "a+") as authors_file:
            with open("types.txt", "a+") as types_file:
                with open("ISBNs.txt", "a+") as ISBNs_file:
                    if len(newTitle.get()) > 0 and len(newAuthor.get()) > 0 and len(newType.get()) > 0:
                        if newTitle.get() in books_file.read():
                            messagebox.showerror("Error", "Duplicate book name")
                        elif newType.get() == "Book":
                            if len(newISBN.get()) == 13:
                                if int(newISBN.get()[0]) == 9 and int(newISBN.get()[1]) == 7 and (int(newISBN.get()[2]) == 8 or int(newISBN.get()[2]) == 9) and (int(newISBN.get()[0]) + int(newISBN.get()[1])*3 + int(newISBN.get()[2]) + int(newISBN.get()[3])*3 + int(newISBN.get()[4]) + int(newISBN.get()[5])*3 + int(newISBN.get()[6]) + int(newISBN.get()[7])*3 + int(newISBN.get()[8]) + int(newISBN.get()[9])*3 + int(newISBN.get()[10]) + int(newISBN.get()[11])*3 + int(newISBN.get()[12])) % 10 == 0:
                                    if newISBN.get() in ISBNs_file.read():
                                        messagebox.showerror("Error", "Duplicate ISBN number")
                                    else:
                                        books_file.write("\n" + newTitle.get())
                                        authors_file.write("\n" + newAuthor.get())
                                        types_file.write("\n" + newType.get())
                                        ISBNs_file.write("\n" + newISBN.get())
                                else:
                                    messagebox.showerror("Error", "Invalid ISBN code")
                            else:
                                messagebox.showerror("Error", "Invalid ISBN code")
                        else:
                            books_file.write("\n" + newTitle.get())
                            authors_file.write("\n" + newAuthor.get())
                            types_file.write("\n" + newType.get())
                            ISBNs_file.write("\n")
                    books_file.close()
                    authors_file.close()
                    types_file.close()
                    ISBNs_file.close()


def delete_entry():
    if len(deletePosition.get()) > 0:
        if str(deletePosition.get()) == str(len(open("books.txt", "r").readlines())-1):
            repeater = 2
        else:
            repeater = 1
    else:
        repeater = 0
    for an_amazing_variable_name in range(repeater):
        len_list = 0
        rebuilding_book_list = []
        rebuilding_author_list = []
        rebuilding_type_list = []
        rebuilding_isbn_list = []
        with (open("books.txt", "r+") as books_file):
            with open("authors.txt", "r+") as authors_file:
                with open("types.txt", "r+") as types_file:
                    with open("ISBNs.txt", "r+") as ISBNs_file:
                        with open("books.txt", "r") as books_file_2:
                            with open("authors.txt", "r") as authors_file_2:
                                with open("types.txt", "r") as types_file_2:
                                    if deletePosition.get().isdigit():
                                        if 0 <= int(deletePosition.get()) <= len(books_file_2.readlines()):
                                            for i in range(len(authors_file_2.read())):
                                                if not i == int(deletePosition.get()):
                                                    if not types_file_2.readline() == "":
                                                        rebuilding_book_list.append(books_file.readline())
                                                        rebuilding_author_list.append(authors_file.readline())
                                                        rebuilding_type_list.append(types_file.readline())
                                                        rebuilding_isbn_list.append(ISBNs_file.readline())
                                                        len_list += 1
                                                else:
                                                    books_file.readline()
                                                    authors_file.readline()
                                                    types_file.readline()
                                                    ISBNs_file.readline()
                                            books_file.close()
                                            authors_file.close()
                                            types_file.close()
                                            ISBNs_file.close()
                                            books_file_2.close()
                                            authors_file_2.close()
                                            types_file_2.close()
                                        else:
                                            messagebox.showerror("Error", "Invalid entry position")
                                            return "no thing"
                                    else:
                                        messagebox.showerror("Error", "Invalid entry position")
                                        return "nothings"
        with open("books.txt", "w+") as books_file_w:
            with open("authors.txt", "w+") as authors_file_w:
                with open("types.txt", "w+") as types_file_w:
                    with open("ISBNs.txt", "w+") as ISBNs_file_w:
                        for i in range(len_list):
                            if not (i + 1 >= len_list and int(deletePosition.get()) == len_list):
                                books_file_w.write(rebuilding_book_list[i])
                                authors_file_w.write(rebuilding_author_list[i])
                                types_file_w.write(rebuilding_type_list[i])
                                ISBNs_file_w.write(rebuilding_isbn_list[i])
                            else:
                                books_file_w.write(rebuilding_book_list[i][:-1])
                                authors_file_w.write(rebuilding_author_list[i][:-1])
                                types_file_w.write(rebuilding_type_list[i][:-1])
                                ISBNs_file_w.write(rebuilding_isbn_list[i][:-1])
                        books_file_w.close()
                        authors_file_w.close()
                        types_file_w.close()
                        ISBNs_file_w.close()
    return "nothing"


def search():
    global books, book_list, authors, author_list, types, type_list, ISBNs, ISBN_list

    # Load data from files
    books = open("books.txt", "r").read()
    book_list = books.split("\n")
    authors = open("authors.txt", "r").read()
    author_list = authors.split("\n")
    types = open("types.txt", "r").read()
    type_list = types.split("\n")
    ISBNs = open("ISBNs.txt", "r").read()
    ISBN_list = ISBNs.split("\n")

    lower_books = books.lower().split("\n")
    lower_authors = authors.lower().split("\n")
    lower_types = types.lower().split("\n")
    lower_isbns = ISBNs.lower().split("\n")

    # Clear current entries in the Treeview
    for item in tree.get_children():
        tree.delete(item)

    search_term = searchText.get().lower()
    search_type_index = searchType.current()

    # Search logic based on selected search type
    for i in range(len(book_list)):
        match = False
        if search_type_index == 0 and search_term in lower_books[i]:
            match = True
        elif search_type_index == 1 and search_term in lower_authors[i]:
            match = True
        elif search_type_index == 2 and search_term in lower_types[i]:
            match = True
        elif search_type_index == 3 and search_term in lower_isbns[i]:
            match = True

        if match:
            tree.insert('', 'end', values=(
                i,
                book_list[i],
                author_list[i],
                type_list[i],
                ISBN_list[i]
            ))


def show_help():
    help_text = (
        "üìö How to Use the Library Database:\n\n"
        "‚û°Ô∏è See All Entries:\n"
        "- Click 'See All Entries (old format)' or 'Update Entries' to view the current list of stored books.\n\n"
        "‚úèÔ∏è Edit Book Info:\n"
        "- Use the appropriate input boxes to change the title, author, type, or ISBN.\n"
        "- Enter the entry number in the first box and the new value in the second.\n\n"
        "‚ûï Add a New Entry:\n"
        "- Fill out the title, author, type, and ISBN fields.\n"
        "- Click 'Save new entry' to add it.\n\n"
        "üóë Delete an Entry:\n"
        "- Type the entry number into the delete box and click 'Delete item at position:'.\n\n"
        "üîç Search:\n"
        "- Select a category and type a search term, then click 'Search'.\n\n"
        "‚ùì Need more help?\n"
        "- Ask ChatGPT."
    )
    messagebox.showinfo("How to Use This Project", help_text)


def on_resize(a):
    width = root.winfo_width()
    height = root.winfo_height()
    btnDisplay.place(x=width - 350, y=height // 2 - 145)


# Creating a tkinter window
root = Tk()
root.geometry('1000x600')
root.title("Library Database")

# Frame for the table
table_frame = Frame(root)
table_frame.pack(side=RIGHT, fill=NONE, expand=False, padx=10, pady=10)

# Scrollbar
table_scroll = Scrollbar(table_frame)
table_scroll.pack(side=RIGHT, fill=Y, expand=False)

# Treeview widget
tree = ttk.Treeview(table_frame, yscrollcommand=table_scroll.set, selectmode="browse")
tree.pack(fill=BOTH, expand=False)

table_scroll.config(command=tree.yview)

# Define table columns
tree['columns'] = ("ID", "Title", "Author", "Type", "ISBN")

tree.column("#0", width=0, stretch=NO)
tree.column("ID", anchor=CENTER, width=40, stretch=NO)
tree.column("Title", anchor=W, width=200, stretch=NO)
tree.column("Author", anchor=W, width=100, stretch=NO)
tree.column("Type", anchor=CENTER, width=80, stretch=NO)
tree.column("ISBN", anchor=W, width=130, stretch=NO)

# Define headings
tree.heading("#0", text="", anchor=W)
tree.heading("ID", text="ID", anchor=CENTER)
tree.heading("Title", text="Title", anchor=W)
tree.heading("Author", text="Author", anchor=W)
tree.heading("Type", text="Type", anchor=CENTER)
tree.heading("ISBN", text="ISBN", anchor=W)

# Button to load/display the data
btnDisplay = Button(root, text="Update Entries", command=display_books, cursor="hand2")
btnDisplay.place(x=len("The x originally will not matter because it will change when the window size changes (including"
                       " when the screen loads)."), y=len("The y doesn't matter either."))

display_books()

# Creating the See Books button
btnSeeBooks = Button(root, text="See all entries (old format)", command=print_stuff, cursor="hand2")
btnSeeBooks.place(x=5, y=5)

# Creating the edit a book button
btnEditABook = Button(root, text="Save title edits (box 1 is the entry number; box 2 is the new title)", command=edit_book, cursor="hand2")
btnEditABook.place(x=5, y=35)

# Creating input areas for editing books
bookNumberInputArea = Entry(root, width=3, bg="light yellow")
bookNumberInputArea.place(x=5, y=68)
bookTitleInputArea = Entry(root, width=45, bg="light yellow")
bookTitleInputArea.place(x=40, y=68)

# Creating the edit authors button
btnEditAnAuthor = Button(root, text="Save author edits (box 1 is the entry number; box 2 is the new author name)", command=edit_author, cursor="hand2")
btnEditAnAuthor.place(x=5, y=95)

# Creating input areas for editing authors
bookNumberAuthorInputArea = Entry(root, width=3, bg="light yellow")
bookNumberAuthorInputArea.place(x=5, y=128)
bookAuthorInputArea = Entry(root, width=20, bg="light yellow")
bookAuthorInputArea.place(x=40, y=128)

# Creating the edit type button
btnEditAType = Button(root, text="Save type edits (box 1 is the entry number; box 2 is the new type)", command=edit_type, cursor="hand2")
btnEditAType.place(x=5, y=155)

# Creating input areas for editing types
bookNumberTypeInputArea = Entry(root, width=3, bg="light yellow")
bookNumberTypeInputArea.place(x=5, y=188)
bookTypeInputArea = Entry(root, width=7, bg="light yellow")
bookTypeInputArea.place(x=40, y=188)

# Creating the edit ISBN button
btnEditAnISBN = Button(root, text="Save ISBN edits (box 1 is the entry number; box 2 is the new ISBN)", command=edit_isbn, cursor="hand2")
btnEditAnISBN.place(x=5, y=215)

# Creating input areas for editing ISBNs
bookNumberISBNInputArea = Entry(root, width=3, bg="light yellow")
bookNumberISBNInputArea.place(x=5, y=248)
bookISBNInputArea = Entry(root, width=13, bg="light yellow")
bookISBNInputArea.place(x=40, y=248)

# Creating the save new entry button
btnSaveNewEntry = Button(root, text="Save new entry", command=save_new_entry, cursor="hand2")
btnSaveNewEntry.place(x=5, y=308)

# Creating the input areas for the new entry button
bookText = Label(root, text="Name:")
bookText.place(x=5, y=341)
newTitle = Entry(root, width=45, bg="light yellow")
newTitle.place(x=48, y=341)

authorText = Label(root, text="Author/director/creator:")
authorText.place(x=5, y=366)
newAuthor = Entry(root, width=20, bg="light yellow")
newAuthor.place(x=140, y=366)

typeText = Label(root, text="Type:")
typeText.place(x=5, y=391)
newType = Entry(root, width=7, bg="light yellow")
newType.place(x=42, y=391)

ISBNText = Label(root, text="ISBN (for books only):")
ISBNText.place(x=5, y=416)
newISBN = Entry(root, width=13, bg="light yellow")
newISBN.place(x=127, y=416)

# Delete item button
deleteButton = Button(root, text="Delete item at position:", command=delete_entry)
deleteButton.place(x=5, y=473)
deletePosition = Entry(root, width=3, bg="light yellow")
deletePosition.place(x=140, y=476)

# Search button
searchButton = Button(root, text="Search", command=search)
searchButton.place(x=5, y=525)
searchType = ttk.Combobox(state="readonly", values=["Name", "Author/creator", "Type", "ISBN"])
searchType.place(x=55, y=527)
searchText = Entry(root, width=45, bg="light yellow")
searchText.place(x=5, y=560)

help_button = Button(root, text="‚ùì", command=show_help, cursor="question_arrow")
help_button.place(x=160, y=5)

root.bind("<Configure>", on_resize)

root.mainloop()
